#include <iostream>
#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>

#include <image_transport/image_transport.h>
#include <opencv/cv.h>
#include <cv_bridge/cv_bridge.h>
#include <image_geometry/pinhole_camera_model.h>
//#include <tf/transform_listener.h>
//#include <boost/foreach.hpp>
#include <sensor_msgs/image_encodings.h>

ros::Publisher pub;
image_geometry::PinholeCameraModel cam_model_;

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);

void RunGroundSegmentation(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_p)
{
    pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
    // Create the segmentation object
    pcl::SACSegmentation<pcl::PointXYZ> seg;

    pcl::ExtractIndices<pcl::PointXYZ> extract;

    // Optional
    seg.setOptimizeCoefficients(true);
    // Mandatory
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setDistanceThreshold (0.05);

    seg.setInputCloud(cloud);
    seg.segment(*inliers, *coefficients);

    if (inliers->indices.size () != 0)
    {
        extract.setInputCloud(cloud);
        extract.setIndices(inliers);
        extract.setNegative (false);
        extract.filter(*cloud_p);
    }
    else
    {
        std::cerr << "ERROR: Could not estimate a planar model for the given dataset." << std::endl;
    }
}

void cloud_cb(const sensor_msgs::PointCloud2ConstPtr& cloud_msg) 
{
    //sensor_msgs::PointCloud2 output_cloud;
    
    //pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::fromROSMsg(*cloud_msg, *cloud);

    //ROS_INFO_STREAM(" Width = "<<cloud_msg->width<<" Height = "<<cloud_msg->height);

    //RunGroundSegmentation(cloud, cloud_filtered);
    
    
    if (cloud_filtered->points.size() != 0)
    {
        pcl::toROSMsg(*cloud_filtered, output_cloud);
        pub.publish(output_cloud);
    }
    else
    {
        std::cerr << "ERROR: Could not estimate a planar model for the given dataset." << std::endl;
    }
    */

    
}


void imageCb(const sensor_msgs::ImageConstPtr& image_msg,
               const sensor_msgs::CameraInfoConstPtr& info_msg)
{
	/*
	cv::Mat image;
	cv_bridge::CvImagePtr input_bridge;
	try {
	input_bridge = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::BGR8);
	image = input_bridge->image;
	}
	catch (cv_bridge::Exception& ex){
	ROS_ERROR("[draw_frames] Failed to convert image");
	return;
	}
	*/
	ROS_INFO_STREAM("Cloud Data Size =" <<cloud->points.size());

	cam_model_.fromCameraInfo(info_msg);
	
	
	if (cloud->points.size() > 0)
	{ 	

	  for(size_t i = 0; i < cloud->points.size(); i++)
	  {
		if(cloud->points[i].z!=0)
		{	

		//tf::Point pt = transform.getOrigin();
		//cv::Point3d pt_cv(0, -10, -10.0);

		//std::vector<pcl::PointXYZ, Eigen::aligned_allocator<pcl::PointXYZ> > data = cloud->points;

		cv::Point3d pt_cv(cloud->points[i].x,cloud->points[i].y, cloud->points[i].z);
		cv::Point2d uv;
		uv = cam_model_.project3dToPixel(pt_cv);

		ROS_INFO_STREAM("Projection of x ="<< cloud->points[i].x<<" y = "<< cloud->points[i].y<<" z = "<< cloud->points[i].z<<" is at  u = "<<uv.x<<" v = "<<uv.y);
		}
		break;
	  }
	}
	
}

int main(int argc, char* argv[])
{
	ros::init (argc, argv, "project3dtouv");
	ros::NodeHandle nh;
	
	image_transport::ImageTransport it_(nh);	
		
	image_transport::CameraSubscriber subCam = it_.subscribeCamera("camera/image_raw", 100,imageCb);
	
	
	// Get point cloud data (x,y,z)	
	ros::Subscriber subCloud = nh.subscribe("velodyne_points", 100, cloud_cb);

	//pub = nh.advertise<sensor_msgs::PointCloud2>("lane_detection/ground_segmentation", 100);

	// Project the point cloud data to pixel position using camera model

	// Print the pixel position   
    

	ros::spin();
}





